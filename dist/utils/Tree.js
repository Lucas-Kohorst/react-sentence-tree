"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDependencyTree = getDependencyTree;
exports.getConstituencyTree = getConstituencyTree;

var _corenlp = _interopRequireWildcard(require("corenlp"));

var _transform = require("./transform");

var _dfs = require("./dfs");

var _fallbackData = require("./fallbackData");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Start a CoreNLP server
 * @see https://stanfordnlp.github.io/CoreNLP/download.html
 * @see https://github.com/stanfordnlp/CoreNLP/blob/master/README.md
 * @see https://www.npmjs.com/package/corenlp
 * @run using `npm explore corenlp -- npm run corenlp:server` with corenlp installed
 * @run using `java -mx4g -cp "*" edu.stanford.nlp.pipeline.StanfordCoreNLPServer -port 9000 -timeout 15000`
 */

/**
 * Takes in a sentence and returns
 * the JSON data of the sentence's dependency tree
 * @param {String} treeData the sentence structure data
 * @param {String} language the language to parse
 */
function getDependencyTree(sentence, language) {
  return new Promise(function (resolve, reject) {
    var props = new _corenlp.Properties({
      annotators: "parse"
    });
    var pipeline = new _corenlp.Pipeline(props, language); // uses ConnectorServer by default

    var sent = new _corenlp["default"].simple.Sentence(sentence);
    pipeline.annotate(sent).then(function (sent) {
      // Adding an attribute "Name" with the POS and word to each element in the array
      // Returning the new TreeData
      var dependency = sent.governors();
      var dependencyTree = []; // Adding all of the dependency's to the initial list

      dependency.forEach(function (value) {
        var dependencyArray = [];
        var governorGloss = value.governorGloss() == "" ? "ROOT" : value.governorGloss();
        dependencyArray.push(value.dep());
        dependencyArray.push(governorGloss);
        dependencyArray.push(value.dependentGloss());
        dependencyTree.push(dependencyArray);
      });
      var treeData = (0, _dfs.dfsDependency)((0, _transform.transformDependencies)(dependencyTree));
      resolve(treeData);
    })["catch"](function (err) {
      resolve(_fallbackData.fallbackDependency);
    });
  });
}
/**
 * Takes in a sentence and returns
 * the JSON data of the sentence's dependency tree
 * @param {String} treeData the sentence structure data
 * @param {String} language the language to parse
 */


function getConstituencyTree(sentence, language) {
  return new Promise(function (resolve, reject) {
    var props = new _corenlp.Properties({
      annotators: "parse"
    });
    var pipeline = new _corenlp.Pipeline(props, language); // uses ConnectorServer by default

    var sent = new _corenlp["default"].simple.Sentence(sentence);
    pipeline.annotate(sent).then(function (sent) {
      var treeString = JSON.stringify(_corenlp["default"].util.Tree.fromSentence(sent).rootNode);
      var treeJSON = JSON.parse(treeString); // Adding an attribute "Name" with the POS and word to each element in the array
      // Returning the new TreeData

      var treeDFS = (0, _dfs.dfsConstituency)(treeJSON);
      var treeDFSString = JSON.stringify(treeDFS, null, 2);
      var treeData = JSON.parse(treeDFSString);
      resolve(treeData);
    })["catch"](function (err) {
      resolve(_fallbackData.fallbackConstituency);
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9UcmVlLmpzIl0sIm5hbWVzIjpbImdldERlcGVuZGVuY3lUcmVlIiwic2VudGVuY2UiLCJsYW5ndWFnZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicHJvcHMiLCJQcm9wZXJ0aWVzIiwiYW5ub3RhdG9ycyIsInBpcGVsaW5lIiwiUGlwZWxpbmUiLCJzZW50IiwiQ29yZU5MUCIsInNpbXBsZSIsIlNlbnRlbmNlIiwiYW5ub3RhdGUiLCJ0aGVuIiwiZGVwZW5kZW5jeSIsImdvdmVybm9ycyIsImRlcGVuZGVuY3lUcmVlIiwiZm9yRWFjaCIsInZhbHVlIiwiZGVwZW5kZW5jeUFycmF5IiwiZ292ZXJub3JHbG9zcyIsInB1c2giLCJkZXAiLCJkZXBlbmRlbnRHbG9zcyIsInRyZWVEYXRhIiwiZXJyIiwiZmFsbGJhY2tEZXBlbmRlbmN5IiwiZ2V0Q29uc3RpdHVlbmN5VHJlZSIsInRyZWVTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwidXRpbCIsIlRyZWUiLCJmcm9tU2VudGVuY2UiLCJyb290Tm9kZSIsInRyZWVKU09OIiwicGFyc2UiLCJ0cmVlREZTIiwidHJlZURGU1N0cmluZyIsImZhbGxiYWNrQ29uc3RpdHVlbmN5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFFQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQU1BLFNBQVNBLGlCQUFULENBQTJCQyxRQUEzQixFQUFxQ0MsUUFBckMsRUFBK0M7QUFDM0MsU0FBTyxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ3BDLFFBQU1DLEtBQUssR0FBRyxJQUFJQyxtQkFBSixDQUFlO0FBQ3pCQyxNQUFBQSxVQUFVLEVBQUU7QUFEYSxLQUFmLENBQWQ7QUFHQSxRQUFNQyxRQUFRLEdBQUcsSUFBSUMsaUJBQUosQ0FBYUosS0FBYixFQUFvQkosUUFBcEIsQ0FBakIsQ0FKb0MsQ0FJWTs7QUFFaEQsUUFBTVMsSUFBSSxHQUFHLElBQUlDLG9CQUFRQyxNQUFSLENBQWVDLFFBQW5CLENBQTRCYixRQUE1QixDQUFiO0FBQ0FRLElBQUFBLFFBQVEsQ0FDSE0sUUFETCxDQUNjSixJQURkLEVBRUtLLElBRkwsQ0FFVSxVQUFBTCxJQUFJLEVBQUk7QUFDVjtBQUNBO0FBQ0EsVUFBSU0sVUFBVSxHQUFHTixJQUFJLENBQUNPLFNBQUwsRUFBakI7QUFDQSxVQUFJQyxjQUFjLEdBQUcsRUFBckIsQ0FKVSxDQU1WOztBQUNBRixNQUFBQSxVQUFVLENBQUNHLE9BQVgsQ0FBbUIsVUFBQUMsS0FBSyxFQUFJO0FBQ3hCLFlBQUlDLGVBQWUsR0FBRyxFQUF0QjtBQUNBLFlBQUlDLGFBQWEsR0FDYkYsS0FBSyxDQUFDRSxhQUFOLE1BQXlCLEVBQXpCLEdBQThCLE1BQTlCLEdBQXVDRixLQUFLLENBQUNFLGFBQU4sRUFEM0M7QUFFQUQsUUFBQUEsZUFBZSxDQUFDRSxJQUFoQixDQUFxQkgsS0FBSyxDQUFDSSxHQUFOLEVBQXJCO0FBQ0FILFFBQUFBLGVBQWUsQ0FBQ0UsSUFBaEIsQ0FBcUJELGFBQXJCO0FBQ0FELFFBQUFBLGVBQWUsQ0FBQ0UsSUFBaEIsQ0FBcUJILEtBQUssQ0FBQ0ssY0FBTixFQUFyQjtBQUNBUCxRQUFBQSxjQUFjLENBQUNLLElBQWYsQ0FBb0JGLGVBQXBCO0FBQ0gsT0FSRDtBQVVBLFVBQUlLLFFBQVEsR0FBRyx3QkFBYyxzQ0FBc0JSLGNBQXRCLENBQWQsQ0FBZjtBQUVBZixNQUFBQSxPQUFPLENBQUN1QixRQUFELENBQVA7QUFDSCxLQXRCTCxXQXVCVyxVQUFBQyxHQUFHLEVBQUk7QUFDVnhCLE1BQUFBLE9BQU8sQ0FBQ3lCLGdDQUFELENBQVA7QUFDSCxLQXpCTDtBQTBCSCxHQWpDTSxDQUFQO0FBa0NIO0FBQ0Q7Ozs7Ozs7O0FBTUEsU0FBU0MsbUJBQVQsQ0FBNkI3QixRQUE3QixFQUF1Q0MsUUFBdkMsRUFBaUQ7QUFDN0MsU0FBTyxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ3BDLFFBQU1DLEtBQUssR0FBRyxJQUFJQyxtQkFBSixDQUFlO0FBQ3pCQyxNQUFBQSxVQUFVLEVBQUU7QUFEYSxLQUFmLENBQWQ7QUFHQSxRQUFNQyxRQUFRLEdBQUcsSUFBSUMsaUJBQUosQ0FBYUosS0FBYixFQUFvQkosUUFBcEIsQ0FBakIsQ0FKb0MsQ0FJWTs7QUFFaEQsUUFBTVMsSUFBSSxHQUFHLElBQUlDLG9CQUFRQyxNQUFSLENBQWVDLFFBQW5CLENBQTRCYixRQUE1QixDQUFiO0FBQ0FRLElBQUFBLFFBQVEsQ0FDSE0sUUFETCxDQUNjSixJQURkLEVBRUtLLElBRkwsQ0FFVSxVQUFBTCxJQUFJLEVBQUk7QUFDVixVQUFJb0IsVUFBVSxHQUFHQyxJQUFJLENBQUNDLFNBQUwsQ0FDYnJCLG9CQUFRc0IsSUFBUixDQUFhQyxJQUFiLENBQWtCQyxZQUFsQixDQUErQnpCLElBQS9CLEVBQXFDMEIsUUFEeEIsQ0FBakI7QUFHQSxVQUFJQyxRQUFRLEdBQUdOLElBQUksQ0FBQ08sS0FBTCxDQUFXUixVQUFYLENBQWYsQ0FKVSxDQU1WO0FBQ0E7O0FBQ0EsVUFBSVMsT0FBTyxHQUFHLDBCQUFnQkYsUUFBaEIsQ0FBZDtBQUNBLFVBQUlHLGFBQWEsR0FBR1QsSUFBSSxDQUFDQyxTQUFMLENBQWVPLE9BQWYsRUFBd0IsSUFBeEIsRUFBOEIsQ0FBOUIsQ0FBcEI7QUFDQSxVQUFJYixRQUFRLEdBQUdLLElBQUksQ0FBQ08sS0FBTCxDQUFXRSxhQUFYLENBQWY7QUFFQXJDLE1BQUFBLE9BQU8sQ0FBQ3VCLFFBQUQsQ0FBUDtBQUNILEtBZkwsV0FnQlcsVUFBQUMsR0FBRyxFQUFJO0FBQ1Z4QixNQUFBQSxPQUFPLENBQUNzQyxrQ0FBRCxDQUFQO0FBQ0gsS0FsQkw7QUFtQkgsR0ExQk0sQ0FBUDtBQTJCSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb3JlTkxQLCB7IFByb3BlcnRpZXMsIFBpcGVsaW5lIH0gZnJvbSBcImNvcmVubHBcIjtcbmltcG9ydCB7IHRyYW5zZm9ybURlcGVuZGVuY2llcywgdHJhbnNmb3JtQ29uc3RpdHVlbmN5IH0gZnJvbSBcIi4vdHJhbnNmb3JtXCI7XG5pbXBvcnQgeyBkZnNDb25zdGl0dWVuY3ksIGRmc0RlcGVuZGVuY3kgfSBmcm9tIFwiLi9kZnNcIjtcbmltcG9ydCB7IGZhbGxiYWNrRGVwZW5kZW5jeSwgZmFsbGJhY2tDb25zdGl0dWVuY3kgfSBmcm9tIFwiLi9mYWxsYmFja0RhdGFcIjtcblxuLyoqXG4gKiBTdGFydCBhIENvcmVOTFAgc2VydmVyXG4gKiBAc2VlIGh0dHBzOi8vc3RhbmZvcmRubHAuZ2l0aHViLmlvL0NvcmVOTFAvZG93bmxvYWQuaHRtbFxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3RhbmZvcmRubHAvQ29yZU5MUC9ibG9iL21hc3Rlci9SRUFETUUubWRcbiAqIEBzZWUgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29yZW5scFxuICogQHJ1biB1c2luZyBgbnBtIGV4cGxvcmUgY29yZW5scCAtLSBucG0gcnVuIGNvcmVubHA6c2VydmVyYCB3aXRoIGNvcmVubHAgaW5zdGFsbGVkXG4gKiBAcnVuIHVzaW5nIGBqYXZhIC1teDRnIC1jcCBcIipcIiBlZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5lLlN0YW5mb3JkQ29yZU5MUFNlcnZlciAtcG9ydCA5MDAwIC10aW1lb3V0IDE1MDAwYFxuICovXG5cbi8qKlxuICogVGFrZXMgaW4gYSBzZW50ZW5jZSBhbmQgcmV0dXJuc1xuICogdGhlIEpTT04gZGF0YSBvZiB0aGUgc2VudGVuY2UncyBkZXBlbmRlbmN5IHRyZWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmVlRGF0YSB0aGUgc2VudGVuY2Ugc3RydWN0dXJlIGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBsYW5ndWFnZSB0aGUgbGFuZ3VhZ2UgdG8gcGFyc2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeVRyZWUoc2VudGVuY2UsIGxhbmd1YWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBuZXcgUHJvcGVydGllcyh7XG4gICAgICAgICAgICBhbm5vdGF0b3JzOiBcInBhcnNlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBpcGVsaW5lID0gbmV3IFBpcGVsaW5lKHByb3BzLCBsYW5ndWFnZSk7IC8vIHVzZXMgQ29ubmVjdG9yU2VydmVyIGJ5IGRlZmF1bHRcblxuICAgICAgICBjb25zdCBzZW50ID0gbmV3IENvcmVOTFAuc2ltcGxlLlNlbnRlbmNlKHNlbnRlbmNlKTtcbiAgICAgICAgcGlwZWxpbmVcbiAgICAgICAgICAgIC5hbm5vdGF0ZShzZW50KVxuICAgICAgICAgICAgLnRoZW4oc2VudCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQWRkaW5nIGFuIGF0dHJpYnV0ZSBcIk5hbWVcIiB3aXRoIHRoZSBQT1MgYW5kIHdvcmQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIC8vIFJldHVybmluZyB0aGUgbmV3IFRyZWVEYXRhXG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBzZW50LmdvdmVybm9ycygpO1xuICAgICAgICAgICAgICAgIHZhciBkZXBlbmRlbmN5VHJlZSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkaW5nIGFsbCBvZiB0aGUgZGVwZW5kZW5jeSdzIHRvIHRoZSBpbml0aWFsIGxpc3RcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5LmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jeUFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBnb3Zlcm5vckdsb3NzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmdvdmVybm9yR2xvc3MoKSA9PSBcIlwiID8gXCJST09UXCIgOiB2YWx1ZS5nb3Zlcm5vckdsb3NzKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lBcnJheS5wdXNoKHZhbHVlLmRlcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeUFycmF5LnB1c2goZ292ZXJub3JHbG9zcyk7XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lBcnJheS5wdXNoKHZhbHVlLmRlcGVuZGVudEdsb3NzKCkpO1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5VHJlZS5wdXNoKGRlcGVuZGVuY3lBcnJheSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHJlZURhdGEgPSBkZnNEZXBlbmRlbmN5KHRyYW5zZm9ybURlcGVuZGVuY2llcyhkZXBlbmRlbmN5VHJlZSkpO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cmVlRGF0YSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxsYmFja0RlcGVuZGVuY3kpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFRha2VzIGluIGEgc2VudGVuY2UgYW5kIHJldHVybnNcbiAqIHRoZSBKU09OIGRhdGEgb2YgdGhlIHNlbnRlbmNlJ3MgZGVwZW5kZW5jeSB0cmVlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJlZURhdGEgdGhlIHNlbnRlbmNlIHN0cnVjdHVyZSBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ30gbGFuZ3VhZ2UgdGhlIGxhbmd1YWdlIHRvIHBhcnNlXG4gKi9cbmZ1bmN0aW9uIGdldENvbnN0aXR1ZW5jeVRyZWUoc2VudGVuY2UsIGxhbmd1YWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBuZXcgUHJvcGVydGllcyh7XG4gICAgICAgICAgICBhbm5vdGF0b3JzOiBcInBhcnNlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBpcGVsaW5lID0gbmV3IFBpcGVsaW5lKHByb3BzLCBsYW5ndWFnZSk7IC8vIHVzZXMgQ29ubmVjdG9yU2VydmVyIGJ5IGRlZmF1bHRcblxuICAgICAgICBjb25zdCBzZW50ID0gbmV3IENvcmVOTFAuc2ltcGxlLlNlbnRlbmNlKHNlbnRlbmNlKTtcbiAgICAgICAgcGlwZWxpbmVcbiAgICAgICAgICAgIC5hbm5vdGF0ZShzZW50KVxuICAgICAgICAgICAgLnRoZW4oc2VudCA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHRyZWVTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgQ29yZU5MUC51dGlsLlRyZWUuZnJvbVNlbnRlbmNlKHNlbnQpLnJvb3ROb2RlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJlZUpTT04gPSBKU09OLnBhcnNlKHRyZWVTdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkaW5nIGFuIGF0dHJpYnV0ZSBcIk5hbWVcIiB3aXRoIHRoZSBQT1MgYW5kIHdvcmQgdG8gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIC8vIFJldHVybmluZyB0aGUgbmV3IFRyZWVEYXRhXG4gICAgICAgICAgICAgICAgdmFyIHRyZWVERlMgPSBkZnNDb25zdGl0dWVuY3kodHJlZUpTT04pO1xuICAgICAgICAgICAgICAgIHZhciB0cmVlREZTU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkodHJlZURGUywgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgdmFyIHRyZWVEYXRhID0gSlNPTi5wYXJzZSh0cmVlREZTU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJlZURhdGEpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsbGJhY2tDb25zdGl0dWVuY3kpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGdldERlcGVuZGVuY3lUcmVlLCBnZXRDb25zdGl0dWVuY3lUcmVlIH07Il19