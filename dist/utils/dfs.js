"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dfsConstituency = dfsConstituency;
exports.dfsDependency = dfsDependency;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Array of visited nodes
var visitConstituency = []; // Visited Node Counter

var vnConstituency = 0;
/**
 * DFS that traverses the tree
 * and then adds a name attribute
 * in the form of "Word (POS)"
 * to each node
 * @param v the structure to traverse
 */

function dfsConstituency(v) {
  Object.keys(v).forEach(function (k) {
    if (!visitConstituency[vnConstituency++]) {
      // Checking if ROOT
      if (v[k].pos == "ROOT") {
        v[k].name = "ROOT";
      }

      if (_typeof(v[k]) === "object") {
        try {
          // Getting the Word and POS
          var word = v[k].word;
          var pos = v[k].pos.toUpperCase();
        } catch (error) {} // Adding the name attribute


        v[k].name = word + " (" + pos + ")";
        dfsConstituency(v[k]);
      }
    } else {
      visitConstituency.splice(vnConstituency, 0, true);
    }
  });
  return v;
} // Array of visited nodes


var visitDependency = []; // Visited Node Counter

var vnDependency = 0;
/**
 * DFS that traverses the tree
 * and then adds a name attribute
 * in the form of "Word (POS)"
 * to each node
 * @param v the structure to traverse
 */

function dfsDependency(v) {
  Object.keys(v).forEach(function (k) {
    if (!visitDependency[vnDependency++]) {
      // Checking if ROOT
      if (v[k].Relationship == "ROOT") {
        v[k].name = "ROOT";
      }

      if (_typeof(v[k]) === "object") {
        try {
          // Getting the Word and POS
          var word = v[k].Name;
          var pos = v[k].Relationship.toUpperCase();
        } catch (error) {} // Adding the name attribute


        v[k].name = word + " (" + pos + ")";
        dfsDependency(v[k]);
      }
    } else {
      visitDependency.splice(vnDependency, 0, true);
    }
  });
  return v;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9kZnMuanMiXSwibmFtZXMiOlsidmlzaXRDb25zdGl0dWVuY3kiLCJ2bkNvbnN0aXR1ZW5jeSIsImRmc0NvbnN0aXR1ZW5jeSIsInYiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJwb3MiLCJuYW1lIiwid29yZCIsInRvVXBwZXJDYXNlIiwiZXJyb3IiLCJzcGxpY2UiLCJ2aXNpdERlcGVuZGVuY3kiLCJ2bkRlcGVuZGVuY3kiLCJkZnNEZXBlbmRlbmN5IiwiUmVsYXRpb25zaGlwIiwiTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0EsSUFBSUEsaUJBQWlCLEdBQUcsRUFBeEIsQyxDQUNBOztBQUNBLElBQUlDLGNBQWMsR0FBRyxDQUFyQjtBQUNBOzs7Ozs7OztBQU9BLFNBQVNDLGVBQVQsQ0FBeUJDLENBQXpCLEVBQTRCO0FBQ3hCQyxFQUFBQSxNQUFNLENBQUNDLElBQVAsQ0FBWUYsQ0FBWixFQUFlRyxPQUFmLENBQXVCLFVBQVNDLENBQVQsRUFBWTtBQUMvQixRQUFJLENBQUNQLGlCQUFpQixDQUFDQyxjQUFjLEVBQWYsQ0FBdEIsRUFBMEM7QUFDdEM7QUFDQSxVQUFJRSxDQUFDLENBQUNJLENBQUQsQ0FBRCxDQUFLQyxHQUFMLElBQVksTUFBaEIsRUFBd0I7QUFDcEJMLFFBQUFBLENBQUMsQ0FBQ0ksQ0FBRCxDQUFELENBQUtFLElBQUwsR0FBWSxNQUFaO0FBQ0g7O0FBQ0QsVUFBSSxRQUFPTixDQUFDLENBQUNJLENBQUQsQ0FBUixNQUFnQixRQUFwQixFQUE4QjtBQUMxQixZQUFJO0FBQ0E7QUFDQSxjQUFJRyxJQUFJLEdBQUdQLENBQUMsQ0FBQ0ksQ0FBRCxDQUFELENBQUtHLElBQWhCO0FBQ0EsY0FBSUYsR0FBRyxHQUFHTCxDQUFDLENBQUNJLENBQUQsQ0FBRCxDQUFLQyxHQUFMLENBQVNHLFdBQVQsRUFBVjtBQUNILFNBSkQsQ0FJRSxPQUFPQyxLQUFQLEVBQWMsQ0FBRSxDQUxRLENBTTFCOzs7QUFDQVQsUUFBQUEsQ0FBQyxDQUFDSSxDQUFELENBQUQsQ0FBS0UsSUFBTCxHQUFZQyxJQUFJLEdBQUcsSUFBUCxHQUFjRixHQUFkLEdBQW9CLEdBQWhDO0FBQ0FOLFFBQUFBLGVBQWUsQ0FBQ0MsQ0FBQyxDQUFDSSxDQUFELENBQUYsQ0FBZjtBQUNIO0FBQ0osS0FmRCxNQWVPO0FBQ0hQLE1BQUFBLGlCQUFpQixDQUFDYSxNQUFsQixDQUF5QlosY0FBekIsRUFBeUMsQ0FBekMsRUFBNEMsSUFBNUM7QUFDSDtBQUNKLEdBbkJEO0FBb0JBLFNBQU9FLENBQVA7QUFDSCxDLENBRUQ7OztBQUNBLElBQUlXLGVBQWUsR0FBRyxFQUF0QixDLENBQ0E7O0FBQ0EsSUFBSUMsWUFBWSxHQUFHLENBQW5CO0FBQ0E7Ozs7Ozs7O0FBT0EsU0FBU0MsYUFBVCxDQUF1QmIsQ0FBdkIsRUFBMEI7QUFDdEJDLEVBQUFBLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZRixDQUFaLEVBQWVHLE9BQWYsQ0FBdUIsVUFBU0MsQ0FBVCxFQUFZO0FBQy9CLFFBQUksQ0FBQ08sZUFBZSxDQUFDQyxZQUFZLEVBQWIsQ0FBcEIsRUFBc0M7QUFDbEM7QUFDQSxVQUFJWixDQUFDLENBQUNJLENBQUQsQ0FBRCxDQUFLVSxZQUFMLElBQXFCLE1BQXpCLEVBQWlDO0FBQzdCZCxRQUFBQSxDQUFDLENBQUNJLENBQUQsQ0FBRCxDQUFLRSxJQUFMLEdBQVksTUFBWjtBQUNIOztBQUNELFVBQUksUUFBT04sQ0FBQyxDQUFDSSxDQUFELENBQVIsTUFBZ0IsUUFBcEIsRUFBOEI7QUFDMUIsWUFBSTtBQUNBO0FBQ0EsY0FBSUcsSUFBSSxHQUFHUCxDQUFDLENBQUNJLENBQUQsQ0FBRCxDQUFLVyxJQUFoQjtBQUNBLGNBQUlWLEdBQUcsR0FBR0wsQ0FBQyxDQUFDSSxDQUFELENBQUQsQ0FBS1UsWUFBTCxDQUFrQk4sV0FBbEIsRUFBVjtBQUNILFNBSkQsQ0FJRSxPQUFPQyxLQUFQLEVBQWMsQ0FBRSxDQUxRLENBTTFCOzs7QUFDQVQsUUFBQUEsQ0FBQyxDQUFDSSxDQUFELENBQUQsQ0FBS0UsSUFBTCxHQUFZQyxJQUFJLEdBQUcsSUFBUCxHQUFjRixHQUFkLEdBQW9CLEdBQWhDO0FBQ0FRLFFBQUFBLGFBQWEsQ0FBQ2IsQ0FBQyxDQUFDSSxDQUFELENBQUYsQ0FBYjtBQUNIO0FBQ0osS0FmRCxNQWVPO0FBQ0hPLE1BQUFBLGVBQWUsQ0FBQ0QsTUFBaEIsQ0FBdUJFLFlBQXZCLEVBQXFDLENBQXJDLEVBQXdDLElBQXhDO0FBQ0g7QUFDSixHQW5CRDtBQW9CQSxTQUFPWixDQUFQO0FBQ0giLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBcnJheSBvZiB2aXNpdGVkIG5vZGVzXG52YXIgdmlzaXRDb25zdGl0dWVuY3kgPSBbXTtcbi8vIFZpc2l0ZWQgTm9kZSBDb3VudGVyXG52YXIgdm5Db25zdGl0dWVuY3kgPSAwO1xuLyoqXG4gKiBERlMgdGhhdCB0cmF2ZXJzZXMgdGhlIHRyZWVcbiAqIGFuZCB0aGVuIGFkZHMgYSBuYW1lIGF0dHJpYnV0ZVxuICogaW4gdGhlIGZvcm0gb2YgXCJXb3JkIChQT1MpXCJcbiAqIHRvIGVhY2ggbm9kZVxuICogQHBhcmFtIHYgdGhlIHN0cnVjdHVyZSB0byB0cmF2ZXJzZVxuICovXG5mdW5jdGlvbiBkZnNDb25zdGl0dWVuY3kodikge1xuICAgIE9iamVjdC5rZXlzKHYpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoIXZpc2l0Q29uc3RpdHVlbmN5W3ZuQ29uc3RpdHVlbmN5KytdKSB7XG4gICAgICAgICAgICAvLyBDaGVja2luZyBpZiBST09UXG4gICAgICAgICAgICBpZiAodltrXS5wb3MgPT0gXCJST09UXCIpIHtcbiAgICAgICAgICAgICAgICB2W2tdLm5hbWUgPSBcIlJPT1RcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdltrXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldHRpbmcgdGhlIFdvcmQgYW5kIFBPU1xuICAgICAgICAgICAgICAgICAgICB2YXIgd29yZCA9IHZba10ud29yZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHZba10ucG9zLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgICAgICAgICAgLy8gQWRkaW5nIHRoZSBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIHZba10ubmFtZSA9IHdvcmQgKyBcIiAoXCIgKyBwb3MgKyBcIilcIjtcbiAgICAgICAgICAgICAgICBkZnNDb25zdGl0dWVuY3kodltrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpdENvbnN0aXR1ZW5jeS5zcGxpY2Uodm5Db25zdGl0dWVuY3ksIDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHY7XG59XG5cbi8vIEFycmF5IG9mIHZpc2l0ZWQgbm9kZXNcbnZhciB2aXNpdERlcGVuZGVuY3kgPSBbXTtcbi8vIFZpc2l0ZWQgTm9kZSBDb3VudGVyXG52YXIgdm5EZXBlbmRlbmN5ID0gMDtcbi8qKlxuICogREZTIHRoYXQgdHJhdmVyc2VzIHRoZSB0cmVlXG4gKiBhbmQgdGhlbiBhZGRzIGEgbmFtZSBhdHRyaWJ1dGVcbiAqIGluIHRoZSBmb3JtIG9mIFwiV29yZCAoUE9TKVwiXG4gKiB0byBlYWNoIG5vZGVcbiAqIEBwYXJhbSB2IHRoZSBzdHJ1Y3R1cmUgdG8gdHJhdmVyc2VcbiAqL1xuZnVuY3Rpb24gZGZzRGVwZW5kZW5jeSh2KSB7XG4gICAgT2JqZWN0LmtleXModikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIGlmICghdmlzaXREZXBlbmRlbmN5W3ZuRGVwZW5kZW5jeSsrXSkge1xuICAgICAgICAgICAgLy8gQ2hlY2tpbmcgaWYgUk9PVFxuICAgICAgICAgICAgaWYgKHZba10uUmVsYXRpb25zaGlwID09IFwiUk9PVFwiKSB7XG4gICAgICAgICAgICAgICAgdltrXS5uYW1lID0gXCJST09UXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZba10gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXR0aW5nIHRoZSBXb3JkIGFuZCBQT1NcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmQgPSB2W2tdLk5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB2W2tdLlJlbGF0aW9uc2hpcC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgICAgICAgICAgICAgIC8vIEFkZGluZyB0aGUgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICB2W2tdLm5hbWUgPSB3b3JkICsgXCIgKFwiICsgcG9zICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgZGZzRGVwZW5kZW5jeSh2W2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2l0RGVwZW5kZW5jeS5zcGxpY2Uodm5EZXBlbmRlbmN5LCAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2O1xufVxuXG5leHBvcnQgeyBkZnNDb25zdGl0dWVuY3ksIGRmc0RlcGVuZGVuY3kgfTsiXX0=